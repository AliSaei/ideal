---
title: "ideal Users Guide"
author:
- name: Federico Marini
  affiliation: 
  - &id Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), Mainz
  - Center for Thrombosis and Hemostasis (CTH), Mainz
  email: marinif@uni-mainz.de
- name: Harald Binder
  affiliation: *id
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('ideal')`"
abstract: >
  In the scope of differential expression analysis, we provide the R/Bioconductor 
  package `r Biocpkg("ideal")`, which serves as a web application to allow 
  simultaneously for interactive and reproducible analysis. `r Biocpkg("ideal")`
  guides the user throughout the steps of Differential Expression analysis and
  produces a wealth of effective visualizations to facilitate data interpretation,
  in a comprehensive and accessible way for a wide range of scientists.
output: 
  BiocStyle::html_document2:
    toc_float: true
  BiocStyle::pdf_document2:
    toc: true
vignette: >
  %\VignetteIndexEntry{ideal Users Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
  %\VignettePackage{ideal}
  %\VignetteKeywords{GeneExpression, DifferentialExpression, RNASeq, Sequencing, Visualization, QualityControl, GUI, GeneSetEnrichment, ReportWriting}
---

<br>
**Package**: `r Rpackage("ideal")`<br />

**Authors**: `r packageDescription("ideal")[["Author"]]`<br />

**Version**: `r packageDescription("ideal")$Version`<br />

**Compiled date**: `r Sys.Date()`<br />

**License**: `r packageDescription("ideal")[["License"]]`<br />

```{r style, echo = FALSE, results = 'asis'}
# BiocStyle::markdown()
```

```{r setup, echo=FALSE, warning=FALSE}
library(knitr)
set.seed(42)
opts_chunk$set(comment=NA,
               fig.align="center",
               warning=FALSE)
```

# Getting started

`r Biocpkg("ideal")` is an R package distributed as part of the [Bioconductor](http://bioconductor.org) project. To install the package, start R and enter:

```{r installation, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("ideal")
```

If you prefer, you can install and use the development version, which can be retrieved via Github (https://github.com/federicomarini/ideal). To do so, use

```{r installation-github, eval=FALSE}
library("devtools")
install_github("federicomarini/ideal")
```



Once `r Rpackage("ideal")` is installed, it can be loaded by the following command.

```{r loadlibrary, message=FALSE}
library("ideal")
```






# Introduction

`r Biocpkg("pcaExplorer")` is a Bioconductor package containing a Shiny application for
analyzing expression data in different conditions and experimental factors. 

It is a general-purpose interactive companion tool for RNA-seq analysis, which 
guides the user in exploring the Principal Components of the data under inspection.

`r Biocpkg("pcaExplorer")` provides tools and functionality to detect outlier samples, genes
that show particular patterns, and additionally provides a functional interpretation of 
the principal components for further quality assessment and hypothesis generation
on the input data. 

Moreover, a novel visualization approach is presented to simultaneously assess 
the effect of more than one experimental factor on the expression levels.

Thanks to its interactive/reactive design, it is designed to become a practical
companion to any RNA-seq dataset analysis, making exploratory data analysis 
accessible also to the bench biologist, while providing additional insight also
for the experienced data analyst.

Starting from development version 1.1.3, `r Biocpkg("pcaExplorer")` supports reproducible 
research with state saving and automated report generation. Each generated plot and table 
can be exported by simple mouse clicks on the dedicated buttons.

## Citation info

If you use `r Biocpkg("pcaExplorer")` for your analysis, please cite it as here below:

```{r}
citation("pcaExplorer")
```




# Launching the application

After loading the package, the `r Biocpkg("pcaExplorer")` app can be launched in different modes:

- `pcaExplorer(dds = dds, rlt = rlt)`, where `dds` is a `DESeqDataSet` object and `rlt` is a `DESeqTransform`
object, which were created during an existing session for the analysis of an RNA-seq
dataset with the `r Biocpkg("DESeq2")` package

- `pcaExplorer(dds = dds)`, where `dds` is a `DESeqDataSet` object. The `rlt` object is automatically 
computed upon launch.

- `pcaExplorer(countmatrix = countmatrix, coldata = coldata)`, where `countmatrix` is a count matrix, generated
after assigning reads to features such as genes via tools such as `HTSeq-count` or `featureCounts`, and `coldata`
is a data frame containing the experimental covariates of the experiments, such as condition, tissue, cell line,
run batch and so on.

- `pcaExplorer()`, and then subsequently uploading the count matrix and the covariates data frame through the 
user interface. These files need to be formatted as tab separated files, which is a common format for storing
such count values.

Additional parameters and objects that can be provided to the main `r Biocpkg("pcaExplorer")` function are:

- `pca2go`, which is an object created by the `pca2go` function, which scans the genes with high loadings in 
each principal component and each direction, and looks for functions (such as GO Biological Processes) that 
are enriched above the background. The offline `pca2go` function is based on the routines and algorithms of 
the `r Biocpkg("topGO")` package, but as an alternative, this object can be computed live during the execution of the app
exploiting the `goana` function, provided by the `r Biocpkg("limma")` package. Although this likely provides more general
(and probably less informative) functions, it is a good compromise for obtaining a further data interpretation.

- `annotation`, a data frame object, with `row.names` as gene identifiers (e.g. ENSEMBL ids) identical to the 
row names of the count matrix or `dds` object, and an extra column `gene_name`, containing e.g. HGNC-based 
gene symbols. This can be used for making information extraction easier, as ENSEMBL ids (a usual choice when
assigning reads to features) do not provide an immediate readout for which gene they refer to. This can be
either passed as a parameter when launching the app, or also uploaded as a tab separated text file. The package
provides two functions, `get_annotation` and `get_annotation_orgdb`, as a convenient wrapper to obtain the updated
annotation information, respectively from `biomaRt` or via the `org.XX.eg.db` packages.



# Accessing the public instance of `ideal` 


# Deploying to a Shiny Server






# The controls sidebar

Most of the input controls are located in the sidebar, some are as well in the individual tabs of the app.
By changing one or more of the input parameters, the user can get a fine control on what is displayed.


## App settings

Here are the parameters that set input values for most of the tabs. By hovering over with the mouse,
the user can receive additional information on how to set the parameter, powered by the `r CRANpkg("shinyBS")` package.

- **x-axis PC** - Select the principal component to display on the x axis
- **y-axis PC** - Select the principal component to display on the y axis
- **Group/color by** - Select the group of samples to stratify the analysis. Can also assume multiple values.
- **Nr of (most variant) genes** - Number of genes to select for computing the principal components. The top n genes are
selected ranked by their variance inter-samples
- **Alpha** - Color transparency for the plots. Can assume values from 0 (transparent) to 1 (opaque)
- **Labels size** - Size of the labels for the samples in the principal components plots
- **Points size** - Size of the points to be plotted in the principal components plots
- **Variable name size** - Size of the labels for the genes PCA - correspond to the samples names
- **Scaling factor** - Scale value for resizing the arrow corresponding to the variables in the PCA for the genes. It
should be used for mere visualization purposes
- **Color palette** - Select the color palette to be used in the principal components plots. The number of colors 
is selected automatically according to the number of samples and to the levels of the factors of interest
and their interactions
- **Plot style for gene counts** - Plot either boxplots or violin plots, with jittered points superimposed 

## Plot export settings        

**Width** and **height** for the figures to export are input here in cm.

Additional controls available in the single tabs are also assisted by tooltips that show on hovering the mouse.
Normally they are tightly related to the plot/output they are placed nearby.



# The task menu

The task menu, accessible by clicking on the cog icon in the upper right part of the application, provides two 
functionalities:

- `Exit pcaExplorer & save` will close the application and store the content of the `input` and `values` reactive 
objects in two list objects made available in the global environment, called `pcaExplorer_inputs_YYYYMMDD_HHMMSS` and 
`pcaExplorer_values_YYYYMMDD_HHMMSS`
- `Save State as .RData` will similarly store `LiveInputs` and `r_data` in a binary file named
`pcaExplorerState_YYYYMMDD_HHMMSS.Rdata`, without closing the application 


           
# The app panels

The `r Biocpkg("pcaExplorer")` app is structured in different panels, each focused on a different aspect of the 
data exploration. 

Most of the panels work extensively with click-based and brush-based interactions, to gain additional
depth in the explorations, for example by zooming, subsetting, selecting. This is possible thanks to the 
recent developments in the `r CRANpkg("shiny")` package/framework.

The available panels are the described in the following subsections.



## Data Upload

These **file input** controls are available when no `dds` or `countmatrix` + `coldata` are provided. Additionally,
it is possible to upload the `annotation` data frame.

When the objects are already passed as parameters, a brief overview/summary for them is displayed.

<p align="center">
<img src="newsnap_01_upload.png" style="width:800px;"/>
</p>

## Instructions

This is where you most likely are reading this text (otherwise in the package vignette). 

<p align="center">
<img src="newsnap_02_instructions.png" style="width:800px;"/>
</p>


## Counts Table

Interactive tables for the raw, normalized or (r)log-transformed counts are shown in this tab.
The user can also generate a sample-to-sample correlation scatter plot with the selected data.

<p align="center">
<img src="newsnap_03_countstable.png" style="width:800px;"/>
</p>


## Data Overview

This panel displays information on the objects in use, either passed as parameters or 
generated from the count matrix provided. Displayed information comprise the design metadata,
a sample to sample distance heatmap, the number of million of reads per sample and some
basic summary for the counts.


<p align="center">
<img src="newsnap_04_overview.png" style="width:800px;"/>
</p>

## Samples View

This panel displays the PCA projections of sample expression profiles onto any pair of components,
a scree plot, a zoomed PCA plot, a plot of the genes with top and bottom loadings. Additionally, this section 
presents a PCA plot where it is possible to remove samples deemed to be outliers in the analysis, which is 
very useful to check the effect of excluding them. If needed, an interactive 3D visualization of the principal 
components is also available.

<p align="center">
<img src="newsnap_05_samples.png" style="width:800px;"/>
</p>


## Genes View

This panel displays the PCA projections of genes abundances onto any pair of components, with samples
as biplot variables, to identify interesting groups of genes. Zooming is also possible, and clicking on single
genes, a boxplot is returned, grouped by the factors of interest. A static and an interactive heatmap are 
provided, including the subset of selected genes, also displayed as (standardized) expression profiles across the 
samples. These are also reported in `datatable` objects, accessible in the bottom part of the tab.

<p align="center">
<img src="newsnap_06_genes.png" style="width:800px;"/>
</p>


## GeneFinder

The user can search and display the expression values of a gene of interest, either by ID or gene
name, as provided in the `annotation`. A handy panel for quick screening of shortlisted genes, again grouped by
the factors of interest. The graphic can be readily exported as it is, and this can be iterated on a shortlisted
set of genes. For each of them, the underlying data is displayed in an interactive table, also exportable with a 
click.

<p align="center">
<img src="newsnap_07_finder.png" style="width:800px;"/>
</p>

## PCA2GO

This panel shows the functional annotation of the principal components, with GO functions enriched in the 
genes with high loadings on the selected principal components. It allows for the live computing of the object,
that can otherwise provided as a parameter when launching the app. The panel displays a PCA plot for the 
samples, surrounded on each side by the tables with the functions enriched in each component and direction.

<p align="center">
<img src="newsnap_08_pca2go.png" style="width:800px;"/>
</p>

## Multifactor Exploration

This panel allows for the multifactor exploration of datasets with 2 or more experimental factors. The user has to select 
first the two factors and the levels for each. Then, it is possible to combine samples from Factor1-Level1 in the selected
order by clicking on each sample name, one for each level available in the selected Factor2. In order to build the matrix, 
an equal number of samples for each level of Factor 1 is required, to keep the design somehow balanced.
A typical case for choosing factors 1 and 2 is for example when different conditions and tissues are present.

Once constructed, a plot is returned that tries to represent simultaneously the effect of the two factors on the data.
Each gene is represented by a dot-line-dot structure, with the color that is indicating the tissue (factor 2) where the gene 
is mostly expressed. Each gene has two dots, one for each condition level (factor 1), and the position of the points is dictated
by the scores of the principal components calculated on the matrix object. The line connecting the dots is darker when the 
tissue where the gene is mostly expressed varies throughout the conditions. 

This representation is under active development, and it is promising for identifying interesting sets or clusters of genes
according to their behavior on the Principal Components subspaces. Zooming and exporting of the underlying genes is also
allowed by brushing on the main plot.

<p align="center">
<img src="newsnap_09_multifac.png" style="width:800px;"/>
</p>


## Report Editor

The report editor is the backbone for generating and editing the interactive report on the basis of the 
uploaded data and the current state of the application. General `Markdown options` and `Editor options`
are available, and the text editor, based on the `shinyAce` package, contains a comprehensive template 
report, that can be edited to the best convenience of the user.

The editor supports R code autocompletion, making it easy to add new code chunks for additional sections.
A preview is available in the tab itself, and the report can be generated, saved and subsequently shared 
with simple mouse clicks.

<p align="center">
<img src="newsnap_10_editor.png" style="width:800px;"/>
</p>


## About

Contains general information on `r Biocpkg("pcaExplorer")`, including the developer's contact, the link to
the development version in Github, as well as the output of `sessionInfo`, to use for reproducibility sake - 
or bug reporting. Information for citing `r Biocpkg("pcaExplorer")` is also reported.

<p align="center">
<img src="newsnap_11_about.png" style="width:800px;"/>
</p>






# Running `pcaExplorer` on published datasets

We can run `r Biocpkg("pcaExplorer")` for demonstration purpose on published datasets that are available as SummarizedExperiment
in an experiment Bioconductor packages.

We will use the `r Biocpkg("airway")` dataset, which can be installed with this command


```{r installairway, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("airway")
```

This package provides a `RangedSummarizedExperiment` object of read counts in genes for an RNA-Seq experiment 
on four human airway smooth muscle cell lines treated with dexamethasone. More details such as gene models and 
count quantifications can be found in the `r Biocpkg("airway")` package vignette. 

To run `r Biocpkg("pcaExplorer")` on this dataset, the following commands are required. First, prepare the objects to be 
passed as parameters of `r Biocpkg("pcaExplorer")`

```{r loadairway, message=FALSE}
library(airway)
library(DESeq2)

data(airway)

dds_airway <- DESeqDataSet(airway,design= ~ cell + dex)
dds_airway
rld_airway <- rlogTransformation(dds_airway)
rld_airway
```

Then launch the app itself

```{r launchairway, eval=FALSE}
pcaExplorer(dds = dds_airway,
            rlt = rld_airway)
```

The `annotation` for this dataset can be built by exploiting the `r Biocpkg("org.Hs.eg.db")` package

```{r annoairway, message = FALSE}
library(org.Hs.eg.db)
genenames_airway <- mapIds(org.Hs.eg.db,keys = rownames(dds_airway),column = "SYMBOL",keytype="ENSEMBL")
annotation_airway <- data.frame(gene_name = genenames_airway,
                                row.names = rownames(dds_airway),
                                stringsAsFactors = FALSE)
head(annotation_airway)                                
```

or alternatively, by using the `get_annotation` or `get_annotation_orgdb` wrappers.

```{r annofuncs, eval=FALSE}

anno_df_orgdb <- get_annotation_orgdb(dds = dds_airway,
                                      orgdb_species = "org.Hs.eg.db",
                                      idtype = "ENSEMBL")

anno_df_biomart <- get_annotation(dds = dds_airway,
                                  biomart_dataset = "hsapiens_gene_ensembl",
                                  idtype = "ensembl_gene_id")

```

```{r echo=FALSE}
anno_df_orgdb <- get_annotation_orgdb(dds = dds_airway,
                                      orgdb_species = "org.Hs.eg.db",
                                      idtype = "ENSEMBL")
```

```{r}
head(anno_df_orgdb)
```


Then again, the app can be launched with 

```{r launchairwayanno, eval=FALSE}
pcaExplorer(dds = dds_airway,
            rlt = rld_airway,
            annotation = annotation_airway) # or anno_df_orgdb, or anno_df_biomart
```

If desired, alternatives can be used. See the well written annotation workflow available at the Bioconductor site (https://bioconductor.org/help/workflows/annotation/annotation/).

# Running `pcaExplorer` on synthetic datasets

For testing and demonstration purposes, a function is also available to generate synthetic datasets whose counts
are generated based on two or more experimental factors.

This can be called with the command

```{r ddsmultifac}
dds_multifac <- makeExampleDESeqDataSet_multifac(betaSD_condition = 3,betaSD_tissue = 1)
```

See all the available parameters by typing `?makeExampleDESeqDataSet_multifac`. Credits are given to the initial
implementation by Mike Love in the `r Biocpkg("DESeq2")` package.

The following steps run the app with the synthetic dataset

```{r prepsimul}
dds_multifac <- makeExampleDESeqDataSet_multifac(betaSD_condition = 1,betaSD_tissue = 3)
dds_multifac
rld_multifac <- rlogTransformation(dds_multifac)
rld_multifac
## checking how the samples cluster on the PCA plot
pcaplot(rld_multifac,intgroup = c("condition","tissue"))
```

Launch the app for exploring this dataset with 

```{r launchsimul, eval=FALSE}
pcaExplorer(dds = dds_multifac,
            rlt = rld_multifac)
```

When such a dataset is provided, the panel for multifactorial exploration is also usable at its best.


# Functions exported by the package for standalone usage

The functions exported by the `r Biocpkg("pcaExplorer")` package can be also used in a standalone scenario,
provided the required objects are in the working environment. They are listed here for an overview,
but please refer to the documentation for additional details. Where possible, for each function a code 
snippet will be provided for its typical usage.



## `pcaplot`

`pcaplot` plots the sample PCA for `DESeqTransform` objects, such as rlog-transformed data. This is 
the workhorse of the Samples View tab

```{r func-pcaplot}
pcaplot(rld_airway,intgroup = c("cell","dex"),ntop = 1000,
        pcX = 1, pcY = 2, title = "airway dataset PCA on samples - PC1 vs PC2")

# on a different set of principal components...
pcaplot(rld_airway,intgroup = c("dex"),ntop = 1000,
        pcX = 1, pcY = 4, title = "airway dataset PCA on samples - PC1 vs PC4",
        ellipse = TRUE)

```


## `pcaplot3d`

Same as for `pcaplot`, but it uses the `threejs` package for the 3d interactive view.

```{r func-pcaplot3d, eval=FALSE}
pcaplot3d(rld_airway,intgroup = c("cell","dex"),ntop = 1000,
        pcX = 1, pcY = 2, pcZ = 3)
# will open up in the viewer
```


## `pcascree`

`pcascree` produces a scree plot of the PC computed on the samples. A `prcomp` object needs to be 
passed as main argument

```{r func-pcascree}
pcaobj_airway <- prcomp(t(assay(rld_airway)))
pcascree(pcaobj_airway,type="pev",
         title="Proportion of explained proportion of variance - airway dataset")
```

## `correlatePCs` and `plotPCcorrs`

`correlatePCs` and `plotPCcorrs` respectively compute and plot significance of the (cor)relation 
of each covariate versus a principal component. The input for `correlatePCs` is a `prcomp` object

```{r func-correlatepcs}
res_pcairway <- correlatePCs(pcaobj_airway,colData(dds_airway))

res_pcairway

plotPCcorrs(res_pcairway)
```

## `hi_loadings`

`hi_loadings` extracts and optionally plots the genes with the highest loadings

```{r func-hiloadings}
# extract the table of the genes with high loadings
hi_loadings(pcaobj_airway,topN = 10,exprTable=counts(dds_airway))
# or alternatively plot the values
hi_loadings(pcaobj_airway,topN = 10,annotation = annotation_airway)
```


## `genespca`

`genespca` computes and plots the principal components of the genes, eventually displaying 
the samples as in a typical biplot visualization. This is the function in action for the Genes View tab

```{r func-genespca}
groups_airway <- colData(dds_airway)$dex
cols_airway <- scales::hue_pal()(2)[groups_airway]
# with many genes, do not plot the labels of the genes
genespca(rld_airway,ntop=5000,
         choices = c(1,2),
         arrowColors=cols_airway,groupNames=groups_airway,
         alpha = 0.2,
         useRownamesAsLabels=FALSE,
         varname.size = 5
        )
# with a smaller number of genes, plot gene names included in the annotation
genespca(rld_airway,ntop=100,
         choices = c(1,2),
         arrowColors=cols_airway,groupNames=groups_airway,
         alpha = 0.7,
         varname.size = 5,
         annotation = annotation_airway
        )

```


## `topGOtable` 

`topGOtable` is a convenient wrapper for extracting functional GO terms enriched in a subset of genes 
(such as the differentially expressed genes), based on the algorithm and the implementation in the 
`r Biocpkg("topGO")` package

```{r func-topGOtable, eval=FALSE}
# example not run due to quite long runtime
dds_airway <- DESeq(dds_airway)
res_airway <- results(dds_airway)
res_airway$symbol <- mapIds(org.Hs.eg.db,
                            keys=row.names(res_airway),
                            column="SYMBOL",
                            keytype="ENSEMBL",
                            multiVals="first")
res_airway$entrez <- mapIds(org.Hs.eg.db,
                            keys=row.names(res_airway),
                            column="ENTREZID",
                            keytype="ENSEMBL",
                            multiVals="first")
resOrdered <- as.data.frame(res_airway[order(res_airway$padj),])
head(resOrdered)
# extract DE genes
de_df <- resOrdered[resOrdered$padj < .05 & !is.na(resOrdered$padj),]
de_symbols <- de_df$symbol
# extract background genes
bg_ids <- rownames(dds_airway)[rowSums(counts(dds_airway)) > 0]
bg_symbols <- mapIds(org.Hs.eg.db,
                     keys=bg_ids,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
# run the function
topgoDE_airway <- topGOtable(de_symbols, bg_symbols,
                             ontology = "BP",
                             mapping = "org.Hs.eg.db",
                             geneID = "symbol")
```


## `pca2go`

`pca2go` provides a functional interpretation of the principal components, by extracting the genes
with the highest loadings for each PC, and then runs internally `topGOtable` on them for efficient functional
enrichment analysis. Needs a `DESeqTransform` object as main parameter

```{r func-pca2go, eval=FALSE}
pca2go_airway <- pca2go(rld_airway,
                        annotation = annotation_airway,
                        organism = "Hs",
                        ensToGeneSymbol = TRUE,
                        background_genes = bg_ids)
# for a smooth interactive exploration, use DT::datatable
datatable(pca2go_airway$PC1$posLoad)
# display it in the normal R session...
head(pca2go_airway$PC1$posLoad)
# ... or use it for running the app and display in the dedicated tab
pcaExplorer(dds_airway,rld_airway,
            pca2go = pca2go_airway,
            annotation = annotation_airway)

```


## `limmaquickpca2go`

`limmaquickpca2go` is an alternative to `pca2go`, used in the live running app, thanks to its fast 
implementation based on the `limma::goana` function.

```{r func, message = FALSE, eval = FALSE}
goquick_airway <- limmaquickpca2go(rld_airway,
                                   pca_ngenes = 10000,
                                   inputType = "ENSEMBL",
                                   organism = "Hs")
# display it in the normal R session...
head(goquick_airway$PC1$posLoad)
# ... or use it for running the app and display in the dedicated tab
pcaExplorer(dds_airway,rld_airway,
            pca2go = goquick_airway,
            annotation = annotation_airway)


```


## `makeExampleDESeqDataSet_multifac`

`makeExampleDESeqDataSet_multifac` constructs a simulated `DESeqDataSet` of Negative Binomial dataset
from different conditions. The fold changes between the conditions can be adjusted with the `betaSD_condition`
`betaSD_tissue` arguments

```{r func-makedataset}

dds_simu <- makeExampleDESeqDataSet_multifac(betaSD_condition = 3,betaSD_tissue = 0.5)
dds_simu
dds2_simu <- makeExampleDESeqDataSet_multifac(betaSD_condition = 0.5,betaSD_tissue = 2)
dds2_simu

rld_simu <- rlogTransformation(dds_simu)
rld2_simu <- rlogTransformation(dds2_simu)
pcaplot(rld_simu,intgroup = c("condition","tissue")) + 
  ggplot2::ggtitle("Simulated data - Big condition effect, small tissue effect")
pcaplot(rld2_simu,intgroup = c("condition","tissue")) + 
  ggplot2::ggtitle("Simulated data - Small condition effect, bigger tissue effect")
```


## `distro_expr`

Plots the distribution of expression values, either with density lines, boxplots or 
violin plots.

```{r eval=FALSE}
distro_expr(rld_airway,plot_type = "density")
distro_expr(rld_airway,plot_type = "violin")
```

```{r}
distro_expr(rld_airway,plot_type = "boxplot")
```


## `geneprofiler` 

Plots the profile expression of a subset of genes, optionally as standardized values

```{r}
dds <- makeExampleDESeqDataSet_multifac(betaSD_condition = 3,betaSD_tissue = 1)
rlt <- DESeq2::rlogTransformation(dds)
set.seed(42)
geneprofiler(rlt,paste0("gene",sample(1:1000,20)), plotZ = FALSE)
```


## `get_annotation` and `get_annotation_orgdb`

These two wrapper functions retrieve the latest annotations for the `dds` object, to be
used in the call to the `pcaExplorer` function. They use respectively the `biomaRt` package
and the `org.XX.eg.db` packages.

```{r eval=FALSE}
anno_df_biomart <- get_annotation(dds = dds_airway,
                                  biomart_dataset = "hsapiens_gene_ensembl",
                                  idtype = "ensembl_gene_id")

anno_df_orgdb <- get_annotation_orgdb(dds = dds_airway,
                                      orgdb_species = "org.Hs.eg.db",
                                      idtype = "ENSEMBL")
```


## `pair_corr`

Plots the pairwise scatter plots and computes the correlation coefficient on the 
expression matrix provided.

```{r}
# use a subset of the counts to reduce plotting time, it can be time consuming with many samples
pair_corr(counts(dds_airway)[1:100,])
```




# Further development

Additional functionality for the `r Biocpkg("pcaExplorer")` will be added in the future, as it is tightly related to a topic
under current development research. 

Improvements, suggestions, bugs, issues and feedback of any type can be sent to marinif@uni-mainz.de.








# Session Info {.unnumbered}

```{r}
sessionInfo()
# devtools::session_info()
```








Contents
1 Quick start 3
2 Creating and sharing output 6
3 Multi-dimensional scaling plots 7
4 Mean-difference plots 9
4.1 General .................................... 9 4.2 Plottingoptions................................ 10 4.3 Tableoptions ................................. 11
5 XYplots 13
6 Using microarray data 15
7 Appendix 20
7.1 Extramean-differenceplots ......................... 20 7.1.1 edgeR-styleanalysis ......................... 20 7.1.2 DESeq2-styleanalysis ........................ 20
7.2 Rsessioninformation............................. 20
2
1 Quick start
Glimma is a Bioconductor [11] package for interactive visualization of results from dif- ferential expression analyses of RNA-sequencing (RNA-seq) and microarray data. Its functionality is intended to enhance reporting capabilities so that results can be explored more conveniently by end-users. Glimma, which loosely stands for interactive Graphics from limma, extends some of the popular plotting capabilities in the limma [1] pack- age such as multi-dimensional scaling (MDS) plots and mean-difference (MD) plots. For seamless integration between the analysis by external packages and Glimma’s interactive plots, Glimma accepts differential expression results from limma, edgeR [3] or DESeq2 [4] packages as input and creates an html page which presents the results interactively. Figure 1 gives an overview of the input data types and processing functions in Glimma. The displays within Glimma were inspired by visualisations from Degust software [2].
Figure 1: Overview of workflow showing the input and output types for functions in Glimma.
> set.seed(20161000)
> options(digits=2)
> options(width=100)
> options(browser="false")
The main dataset used in this vignette is taken from an RNA-seq experiment exam- ining lymphoma cell lines in mice with alterations to the Smchd1 gene [5]. The count data is available as an edgeR DGEList object within Glimma for 4 wildtype samples and 3 samples that have a null allele of the Smchd1 gene (we call these samples Smchd1-null).
￼> library(Glimma)
> library(limma)
> library(edgeR)
> data(lymphomaRNAseq)
> rnaseq <- lymphomaRNAseq
> rnaseq$samples$group
[1] Smchd1-null Smchd1-null Smchd1-null Smchd1-null WT
Levels: WT Smchd1-null
WT WT
3
Lowly expressed genes are removed from downstream analysis and TMM-normalisation [9] is carried out.
> rnaseq <- rnaseq[rowSums(cpm(rnaseq)>1)>=3,]
> rnaseq <- calcNormFactors(rnaseq)
Using the glMDSPlot functon, an interactive MDS plot can be created to examine the clustering of samples in an unsupervised fashion. Distances in the plot represent similarities and dissimilarities between samples. Glimma’s MDS plot allows users to interactively browse through different dimensions of the plot. A MDS plot is created here using a DGEList object of sample expression and vector specifying sample groups, a screen-capture of the html output is shown in Figure 2.
> groups <- rnaseq$samples$group
> glMDSPlot(rnaseq, groups=groups)
Figure 2: Interactive MDS plot where the dimensions displayed in the MDS plot (left) can be changed by clicking on the associated bars in the barplot (right). Samples, or points, in the MDS plot are colored by genotype.
We demonstrate the usage of Glimma by carrying out a limma-style analysis and using the corresponding output as input to Glimma functions. The same functions would work just as easily on output from edgeR or DESeq2 analyses, where examples of these are shown explicitly in the Appendix in Section 7. Here, differential expression of genes between Smchd1-null and wildtype samples is carried out using limma’s voom with quality weights method [6, 7]. An adjusted p-value cutoff of 5% detects 882 genes as down- regulated in the Smchd1-null group relative to wildtypes, and 634 genes as up-regulated.
> design <- model.matrix(~0+groups)
> contrasts <- cbind(Smchd1null.vs.WT=c(-1,1))
> vm <- voomWithQualityWeights(rnaseq, design=design)
> fit <- lmFit(vm, design=design)
> fit <- contrasts.fit(fit, contrasts)
> fit <- eBayes(fit)
> dt <- decideTests(fit)
> summary(dt)
￼4
   Smchd1null.vs.WT
-1              882
0             10079
1               634
Glimma’s interactive MD plot displays gene-wise log2-fold changes (logFCs) against average expression values together with a plot of sample expression. This allows users to see summarised results from all of the genes as a whole whilst being able to scrutinise the expression of individual genes at the same time. Using the glMDPlot function, a MD plot is created using fit which is an MArrayLM object, and dt a TestResults object that is used to highlight differentially expressed (DE) genes. The EList object from voom contains log2-counts per million (logCPM) values which are used in the plot of sample expression. A screen-capture of the html output is shown in Figure 3.
> glMDPlot(fit, status=dt, counts=vm, groups=groups, side.main="Symbols")
Figure 3: Interactive MD plot where gene-wise logFCs are plotted against mean expres- sion values (top left). Significantly up- and down-regulated genes are highlighted in red and blue respectively. A table of associated gene information is displayed (bottom). Sam- ple expression is displayed for an given gene (top right) by selecting a point in the main plot or a row in the table.
For a general plot of any two gene-wise summarised statistics, the glXYPlot allows one to plot any two vectors of equal length against each other and associate these with sample expression. We display below the R-code for creating a volcano plot using logFC values and log-odds. It is important to ensure that ordering of genes is the same for the two vectors and the expression matrix!
> glXYPlot(x=fit$coef, y=fit$lod, xlab="logFC", ylab="logodds",
+   status=dt, counts=vm, groups=groups, anno=fit$genes)
￼5
2 Creating and sharing output
All interactive plots are automatically saved as html files in a “glimma-plots” folder that is created in the current working directory, unless specified otherwise using the path and folderarguments. BydefaultMDSplotsaresavedas“MDS-Plot.html”,MDplotsas“MD- Plot.html”, and XY plots “XY-Plot.html”. Alternate file names can be specified using the html argument. As each plot is created and saved, an html page is also launched automatically in your default web browser; launch can be set to FALSE if this is not desired.
Glimma’s interactive plots can be distributed to collaborators by sharing the complete “glimma-plots” folder with its contents. Note that sharing html files alone will not work. In an Rmarkdown analysis report the interactive plots can be included as links in their
relevant sections
6
3 Multi-dimensional scaling plots
Interactive MDS plots show similarities between the transcriptional profile of samples via unsupervised clustering. Glimma’s MDS plot can be created on expression data in the form of a numeric matrix, DGEList, Elist, or DESeqDataSet object. Raw counts in an DGEList are automatically converted by glMDSPlot into logCPM values using normali- sation factors within the object. For an equivalent plot using an expression matrix, raw counts need to be manually converted to logCPM values. An example is shown below us- ing the cpm function in edgeR which takes into account the normalisation factors stored within the DGEList.
> lcpm <- cpm(rnaseq, log=TRUE, normalized.lib.sizes=TRUE)
> glMDSPlot(lcpm, groups=groups)
The output contains two key components. On the left is an MDS plot showing two consecutive dimensions plotted against each other with each sample represented by a point in the plot. The distance between two samples reflect the leading logFC or typical logFC of genes separating the samples. By default the top 500 genes are used to calculate distances unless specified otherwise using the top argument. For more information on MDS plots, see ?limma::plotMDS.
On the right, a barplot is displayed representing the proportion of variation in the data that is explained by the dimensions or eigenvectors in the MDS plot. Dimension 1 which explains the largest proportion of variation is associated with the first, left-most bar. The second bar is associated with dimensions 2, the third bar is for dimensions 3, and so on. Clicking on a bar on the page will highlight two consecutive bars and display the associated dimensions in the MDS plot.
Hovering your cursor over each of the points in the MDS plot brings up sample information such as sample labels and groups which can be specified using the labels and groups arguments. The coloring of points in the plot are associated with each unique group label. Typically groups would be a vector specifying the main condition by which samples are separated, but for more complex experimental designs a dataframe can also be used to represent multiple categorical variables.
To demonstrate this, a dataframe is created using genotype and sequencing lane information (all samples were sequenced on lane 4 except for the last sample which was sequenced on lane 3). An interactive MDS plot is created by using the dataframe to define groups. The screen-captures in Figure 4 from the html output shows the switching of sample colors by genotype to sequencing lane, and a change in the displayed dimensions.
> groups.df <- as.data.frame(cbind(
+   genotype=as.character(groups),
+   lane=c(rep(4,6),3)))
> groups.df
     genotype lane
1 Smchd1-null    4
2 Smchd1-null    4
3 Smchd1-null    4
4 Smchd1-null    4
7
5 WT4 6 WT4 7 WT3
> glMDSPlot(lcpm, groups=groups.df)
Figure 4: Interactive MDS plots showing (A) dimensions 1 and 2 with samples colored by group (or genotype) and (B) dimensions 2 and 3 with sampled colored by sequencing lane.
￼8
4 Mean-difference plots 4.1 General
Mean-difference plots provide a visual summary of the results and are useful for high- lighting genes with unusually large absolute logFCs amongst all of the genes that are tested. When “stand out” genes are spotted in the MD plot it is often of interest to see the expression of individual samples for that gene to check the consistency of expression within groups and for the potential of outliers. Glimma’s MD plot makes that connection between summarised results (across all genes) and individual sample expression (for any selected gene) so that the data can be interrogated more thoroughly by having the two plots side-by-side.
Figure 5: Layout of MD plots with three key components – two plots on top and a table below. Green arrows represent the direction of interaction between components.
The interactive MD plot contains three key components which interact with each other to show multiple aspects of the data in the one display. The layout of such a plot is shown in Figure 5. The main component is a plot of gene-wise summarised statistics which takes the top-left panel of the html page. Gene-wise logFCs are plotted against gene-wise average logCPM values where each point on the plot represents a single gene. Hovering your cursor over or clicking on a gene (or point) within the main plot brings the expression of each sample for the selected gene in a plot in the top-right panel At the same time, associated gene information is displayed in the table below.
Users can simply scroll through the table looking for any gene that is of interest, or hone into specific genes or groups of genes using the search function in the table. Clicking on a gene (or row) in the table interacts with both of the plots simultaneously – the selected gene is highlighted in the MD plot and next to it, the expression each sample is displayed.
The order of genes displayed in the table can be re-ordered in an increasing or decreas- ing fashion by clicking on the header of a column. This is useful to see which genes have the smallest raw or adjusted p-value, or for sorting genes into those that are most up- or down-regulated in terms of logFC. The ordering function in the table used in conjunction with the search function can be especially powerful as an exploratory tool, for example,
￼9
one can search by a keyword of interest, say “structural maintanence” and then order the reduced table of genes by adjusted p-value.
When working with limma output, average expression values, logFCs and associated gene information are automatically extracted from MArrayLM objects. By default the last coefficient in the object is used unless specifed otherwise using the coef argument. In it’s simplest form, glMDSPlot can take an MArrayLM object alone with counts unspecified, as shown in the R-code below. In this way, only the main plot and table will be displayed.
> glMDPlot(fit)
When it is used, counts can be raw or transformed counts (e.g. cpm or logCPM) that must have the same ordering of genes as in the main argument x. If raw counts are given, they can be transformed into logCPM values by setting transform to TRUE.
4.2 Plotting options
Sample expression can be sorted into groups using the groups argument, where groups is a vector matching in length and order to the samples (or columns) in counts. Typically groups will be a character or factor vector separating samples into different conditions, as demonstrated in Section 1. However, groups can also be a numeric vector associating expression values with a covariate of interest, for example, the age of mice at the time of RNA extraction.
> groups.age <- runif(ncol(rnaseq), min=3, max=12)
> groups.age
[1]  3.6 10.9 11.2  8.9  7.6 10.4  9.5
In the main plot, up- and down-regulated genes can be highlighted using the status argument which is a vector containing integer values of -1 to represent down-regulated genes, 0 for no differential expression, and 1 for up-regulated genes. These values can be given in the form of a numeric vector that is of the same length and ordering of genes in x. Alternatively, if a matrix or a TestResults object is supplied, then the column specified by coef will be used to highlight genes. By default, down-regulated genes are colored in blue and up-regulated genes are in red. Alternatively, your own colors can be specified using the cols argument which accepts both R-defined colors such as “blue”, and numeric values which references your current color palette.
In the side sample expression plot, side.main specifies the column from table which is used as the main title, for example, side.main= “GeneName”. side.xlab and side.ylab is used to specify the labels for x- and y- axes. Sample labels which appear when clicking on or hovering over a point can be changed using the samples argument; and colors of points can be specified using the sample.cols argument. Other arguments include jitter which jitters points horizontally to minimise the amount of overlap (does not apply when groups is numeric), side.log which re-scales the y-axis to a log-scale (but does not transform the data), and side.gridstep which adds horizontal grid lines to the plot.
Using the age of mice in the sample expression plot, we demonstrate the use of some of the options described above (Figure 6). Notice that the color of points in both the MD plot and sample expression plot has changed, and more informative labels have been specified.
10
> cols <- c("yellow","blue","magenta")
> sample.cols <- c("limegreen", "purple")[groups]
> glMDPlot(fit, status=dt, counts=vm, groups=groups.age,
+   sample.cols=sample.cols, cols=cols,
+   side.ylab="logCPM", side.xlab="Age (in months)",
+   side.main="Symbols", main=colnames(dt))
Figure 6: Interactive MD plot (left) where sample expression (right) has been stratified by age. The table is not displayed here to highlight changes to MD and sample expression plots.
4.3 Table options
Gene information is automatically extracted from MArrayLM and DGEList objects and displayed within the table, along with the values for average gene expression, logFC and adjusted p-value. glMDPlot does this by looking under the $genes slot of x.
Extra gene annotation can be added to the table using the anno argument. This would combine and display both the gene information from x and anno, where anno is a dataframe with the same ordering and number of genes as in x. To display specific columns in the table use the display.columns argument.
In the example below, we create extra gene annotation, where ID combines gene sym- bol with Entrez gene ID and DE specifies whether genes are downregulated, upregulated or not differentially expressed (notDE). Using display.columns, we display only ID and DE, and full gene names from fit$genes.
> ID <- paste(fit$genes$Symbols, fit$genes$GeneID)
> DE <- c("downregulated", "notDE", "upregulated")[as.factor(dt)]
> anno <- as.data.frame(cbind(ID, DE))
> head(anno)
           ID            DE
1 Abca1 11303 downregulated
2 Abca2 11305         notDE
3 Abcb7 11306         notDE
4 Abcg1 11307 downregulated
5  Abi1 11308         notDE
6  Abl1 11350 downregulated
￼11
> glMDPlot(fit, counts=vm, groups=groups, side.main="ID",
+   anno=anno, display.columns=c("ID", "GeneName", "DE"))
Figure 7: Interactive MD plot with changes to default gene information displayed in the table.
Adjusted p-values that are included in the table are automatically calculated using the Benjamini and Hochberg method [10] on raw p-values stored within x. Other multiple- testing correction methods that are available in stats::p.adjust can be specified to the p.adj.method argument.
When performing differential expression analyses using edgeR, the examples in this section would work by simply replacing limma’s MArrayLM object with either of edgeR’s DGEExact or DGELRT object; the same goes for DESeqDataSet objects from a DESeq2- style analysis. LogFC values, average expression values and raw p-values are automat- ically extracted from all objects. Gene information, however, is only automatically ex- tracted from the limma and edgeR objects but not for DESeq2. See Subsection ?? and ?? for examples using output from edgeR and DESeq2.
￼12
5 XY plots
Glimma’s XY plots have the same layout as MD plots (Figure 5) but can be used to display any gene-wise summary statistic against any other gene-wise summary statistic as the main plot in the top left panel. The MD plot is essentially the XY plot with the x-component specified as average logCPM values and the y-component specified as logFC values. Since the XY plot is for general usage it works with basic R objects such as vectors, matrices and dataframes, rather than MArrayLM, DGEExact, DGELRT or DESeqDataSet objects where gene information or raw p-values could otherwise be automatically extracted. The two main arguments in glXYPlot are x and y, both of which are numeric vectors of equal length. To create a volcano plot, we specify x as the logFC between Smchd1-null versus wildtype, and y as the log-odds that the gene is DE.
> glXYPlot(x=fit$coef, y=fit$lod)
Since no other information is given to the function, genes are automatically assigned gene identifiers (GeneID) and labels remain as ‘x’ and ‘y’. The labels can be specified as something more meaningful, such as ‘logFC’ and ‘logodds’ using the xlab and ylab arguments.
Other arguments in XY plot are analogous to those that are in the MD plot. In brief, status and cols are used to highlight DE genes in the main plot; anno adds gene information to the table where display.columns specifies the columns that are display; counts is used to add a plot of sample expression with groups separating observations into different conditions; samples and sample.cols labels and colors points in the sample expression plot, where jitter is applied to points avoid overlapping, and side.main is used as the title label.
Using some of the options mentioned, an enhanced version of the volcano plot is created using the R-code below (Figure 8).
> glXYPlot(x=fit$coef, y=fit$lod, xlab="logFC", ylab="logodds",
+   status=dt, anno=anno, side.main="ID",
+   counts=vm, groups=groups, sample.cols=sample.cols)
The XY plot allows users to come up with an unlimited number of plotting combi- nations between any two gene-wise statistcs for a dataset and relate these to sample- specific expression. It can also be used to compare results between datasets, for example the logFC from one experiment could be plotted against the logFC from a second ex- periment, with the corresponding sample expression presented in the left-hand panel as before.
13
￼Figure 8: Interactive volcano plot (top left) with DE genes highlighted, and samples in the sample expression plot (top right) separated into genotype.
14
6 Using microarray data
Although Glimma was developed with RNA-sequencing data analyses in mind and de- signed to interact specifically with the limma, edgeR and DESeq2, it can be just as easily applied to microarray data especially when the data is processed with limma.
In this section, we demonstrate the usage of Glimma on an Illumina microarray dataset taken from a study on the Ezh2 gene in mouse mammary epithelium [13]. The study includes two cell populations, one that is enriched for mammary stem cells (labeled as DP) and another that is enriched for luminal progenitor cells (labeled as Lum). In each population, there are three samples where the Ezh2 gene has been knocked-out (labeled as cre Ezh2) and three wildtype samples (labeled as ev).
For this dataset, normexp [12] background correction and normalisation was carried out, and probes are removed from downstream analysis if they were not detected in any of the samples or are of low quality. Probes are considered as “detected” if they have a detection score of greater than 0.95, and are considered to have reasonable quality if it is graded as “Good” or better. The pre-processed expression data is available within Glimma as an EListRaw object and a targets file of associated sample information is included.
> data(arraydata)
> arrays <- arraydata$arrays
> targets <- arraydata$targets
> dim(arrays)
[1] 10571 12
> targets
   Array SampleID    Condition
Chip Section Experiment
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10    10
11    11
12    12    TB.09        DP ev 5233006024
A          2
B          1
C          2
D          1
E          1
F          1
A          2
B          2
C          3
D          3
E          3
F          3
TB.05        DP ev 5233006042
TB.04 Lum cre Ezh2 5233006042
TB.06  DP cre Ezh2 5233006042
TB.01        DP ev 5233006042
TB.03       Lum ev 5233006042
TB.02  DP cre Ezh2 5233006042
TB.08 Lum cre Ezh2 5233006024
 TB.7       Lum ev 5233006024
TB.11       Lum ev 5233006024
TB.12 Lum cre Ezh2 5233006024
TB.10  DP cre Ezh2 5233006024
An MDS plot is created on the Elist object with samples colored by sample condition, the Illumina beadchip on which samples were processed on, and experiment number. The plot shows that samples separate first by cell population (DP and Lum) over Dimension 1 (Figure 9A), and then separate by the beadchip and experiment over Dimension 2 (Fig- ure 9B,C). Variations in the experimental design are easily explored using the interactive plot.
15
￼Figure 9: Interactive MDS plot with samples colored by condition (A), beadchip (B) and experiment (C). The plot showing the proportion of variation explained by each dimension (top right panel) has been hidden in panels B and C, to highlight the change in MDS Color Group.
> glMDSPlot(arrays, groups=targets[,c("Condition", "Chip", "Experiment")])
Within each cell population we test for the probes that are DE for Ezh2 knock-out versus wildtype using a limma-style analysis. Sample conditions and experiment number is included as parameters used in linear modelling. Using an adjusted p-value of 0.1, 131 probes are detected as DE in the mammary stem cell-enriched population, and 85 probes
16
are detected in the luminal population.
> design <- model.matrix(~0+targets$Condition+as.factor(targets$Experiment)) > contrasts <- cbind(
+   DP_Ezh2KO.vs.WT=c(1,-1,0,0,0,0),
+   Lum_Ezh2KO.vs.WT=c(0,0,1,-1,0,0))
> fit <- lmFit(arrays, design)
> fit <- contrasts.fit(fit, contrasts)
> fit <- eBayes(fit)
> dt <- decideTests(fit, p.value=0.1)
> summary(dt)
   DP_Ezh2KO.vs.WT Lum_Ezh2KO.vs.WT
-1              37               65
0            10440            10486
1               94               20
A MD plot is created for each of the comparisons, with sample expression grouped by condition and colored by experiment number. Since gene identifiers are non-unique in microarray data, probe identifiers are used to label sample expression plots. Amongst the DE top genes that are displayed (as ranked by adjusted p-value), probe 6940037 is up- regulated in the comparison of Ezh2 knock-out versus wildtype in both cell populations (Figure ??).
> sample.cols <- c("purple", "magenta", "green")[targets$Experiment]
> for (COEF in 1:2) {
+
+
+ +}
glMDPlot(fit, status=dt, coef=COEF, main=colnames(fit)[COEF],
  counts=arrays, groups=targets$Condition, sample.cols=sample.cols,
  side.ylab="Log-expression", side.main="ProbeID")
To take a look at both comparisons at the same time, the logFC for DP Ezh2 knock- out versus wildtype is plotted against the logFC for Lum Ezh2 knock-out versus wildtype (Figure 11). Probes that are DE in either one of the comparisons are highlighted in the plot in black, and probes that are DE in both comparisons are highlighted in the plot in red. We search specifically for “Ltf” to find probe 6940037 using the table’s search bar. Probe 6940037 has the largest positive logFC in both comparisons. In general, logFCs in the two cell populations are postively correlated for the comparison between Ezh2 knock-out versus wildtype.
> dt2 <- rep(0, nrow(dt))
> dt2[rowSums(dt!=0)==1] <- -1
> dt2[rowSums(dt!=0)==2] <- 1
> table(dt2)
dt2
-1 0 1
184 10371 16
17
￼Figure 10: Interactive MD plot for the comparison between Ezh2 knock-out and wild- type for A) mammary stem cell-enriched samples and B) luminal populations, where up- regulated genes are colored in red and down-regulated genes are colored in blue. Samples in the sample expression plot are grouped by condition and colored by experiment num- ber. Both tables in A) and B) show the top DE genes are ranked by adjusted p-value. Probe 6940037 for gene Ltf is amongst the top DE genes in both comparisons.
18
> cols <- c("black", "grey", "red")
> glXYPlot(fit$coef[,1], y=fit$coef[,2], xlab="DP", ylab="Lum",
+   status=dt2, cols=cols, anno=fit$genes, side.main="ProbeID",
+   counts=arrays, groups=targets$Condition, sample.cols=sample.cols,
+   side.ylab="Log-expression", main="logFCs")
Figure 11: Interactive plot of logFCs for Ezh2 knock-out versus wildtype in DP (x-axis) and Lum (y-axis) in the top left panel. Probes that are DE in one comparison are highlighted in black, and probes that are DE in both comparisons are highlighted in red. Sample expression is separated into conditions and colored by experiment number. The table of results is restricted to those that match with “Ltf”.
￼19
7 Appendix
7.1 Extra mean-difference plots
7.1.1 edgeR-style analysis
In the R code below, DE analysis is carried out using edgeR’s exact test method. A MD plot is created using a DGEExact object, and dt.edger which is limma’s TestResults object is used to highlight genes that are detected as differentially expressed. Since raw counts are given to the glMDPlot function, a logCPM transformation is carried out using the transform argument. For an analysis using edgeR’s likelihood ratio tests, one can easily replace the DGEExact object below with a DGELRT object.
> groups <- rnaseq$samples$group
> design <- model.matrix(~groups)
> colnames(design) <- c("WT", "Smchd1null.vs.WT")
> rnaseq.edger <- estimateDisp(rnaseq, design=design)
> fit.edger <- exactTest(rnaseq.edger)
> dt.edger <- decideTestsDGE(fit.edger)
> glMDPlot(fit.edger, status=dt.edger, counts=rnaseq, groups=groups, transform=TRUE)
7.1.2 DESeq2-style analysis
Differential expression analysis is carried out here using DESeq2. A MD plot is created using a DESeqResults object. Genes are highlighted (without distinction between up- or down-regulation) using the numeric vector dt.deseq2.
> # BUG regarding the scale of sample expression
> library(DESeq2)
> rnaseq.deseq2 <- DESeqDataSetFromMatrix(
+   rnaseq$counts, colData=rnaseq$samples, design=~group)
> mcols(rnaseq.deseq2) <- DataFrame(mcols(rnaseq.deseq2), rnaseq$genes)
> rnaseq.deseq2 <- DESeq(rnaseq.deseq2)
> fit.deseq2 <- results(rnaseq.deseq2, contrast=c("group", "Smchd1-null", "WT"))
> dt.deseq2 <- as.numeric(fit.deseq2$padj<0.05)
> glMDPlot(fit.deseq2, status=dt.deseq2, counts=rnaseq, groups=groups, transform=FALSE, + samples=colnames(rnaseq), anno=rnaseq$genes)
7.2 R session information
> sessionInfo()
R Under development (unstable) (2016-12-02 r71716)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 16.04.1 LTS
locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
 [4] LC_COLLATE=C               LC_MONETARY=en_US.UTF-8
LC_TIME=en_US.UTF-8
LC_MESSAGES=en_US.UTF-8
20
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C
[10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base
other attached packages:
[1] edgeR_3.17.5  limma_3.31.13 Glimma_1.3.20
loaded via a namespace (and not attached):
[1] compiler_3.4.0  tools_3.4.0     grid_3.4.0      locfit_1.5-9.1  knitr_1.15.1    jsonlite
[7] lattice_0.20-34
21
References
[1] Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, Smyth GK. (2015) limma powers differential expression analyses for RNA-sequencing and microarray studies, Nucleic Acids Research, 43(7):e47.
[2] Powell DR. (2015) Degust: Visualize, explore and appreciate RNA-seq differential gene-expression data, http://victorian-bioinformatics-consortium.github.io/ degust/.
[3] Robinson MD, McCarthy DJ, Smyth GK. (2010) edgeR: a Bioconductor package for differential expression analysis of digital gene expression data, Bioinformatics, 26(1):139–40.
[4] Love MI, Huber W, Anders S. (2014) Moderated estimation of fold change and dis- persion for RNA-seq data with DESeq2, Genome Biology, 15(12):550.
[5] Liu R, Chen K, Jansz N, Blewitt ME, Ritchie, ME (2016) Transcriptional profiling of the epigenetic regulator Smchd1, Genomics Data, 7:144–7.
[6] Law CW, Chen Y, Shi W, Smyth GK (2014) Voom: precision weights unlock linear model analysis tools for RNA-seq read counts, Genome Biology, 15:R29.
[7] Liu R, Holik AZ, Su S, Jansz N, Chen K, Leong HS, Blewitt ME, Asselin-Labat ML, Smyth GK, Ritchie ME (2015) Why weight? Combining voom with estimates of sample quality improves power in RNA-seq analyses, Nucleic Acids Research, 43(15):e97.
[8] McCarthy DJ, Smyth GK (2009) Testing significance relative to a fold-change thresh- old is a TREAT, Bioinformatics, 25(6):765-71.
[9] Robinson MD, Oshlack A (2010) A scaling normalization method for differential ex- pression analysis of RNA-seq data, Genome Biology, 11:R25.
[10] Benjamini Y, Hochberg Y (1995) Controlling the false discovery rate: a practical and powerful approach to multiple testing, Journal of the Royal Statistical Society Series B 57, 289-300.
[11] Huber W, Carey V, Gentleman R, Anders S, Carlson M, Carvalho BS, Bravo HC, Davis S, Gatto L, Girke T, Gottardo R, Hahne F, Hansen KD, Irizarry RA, Lawrence M, Love MI, MacDonald J, Obenchain V, Ole ́s AK, Pag`es H, Reyes A, Shannon P, Smyth GK, Tenenbaum D, Waldron L, Morgan M (2015) Orchestrating high-throughput genomic analysis with Bioconductor, Nature Methods 12(2):151–121.
[12] Shi W, Oshlack A, Smyth GK (2010) Optimizing the noise versus bias trade-off for Illumina Whole Genome Expression BeadChips, Nucleic Acids Research 38e204.
[13] Pal B, Bouras T, Shi W, Vaillant F, Sheridan JM, Fu N, Breslin K, Jiang K, Ritchie ME, Young M, Lindeman GJ, Smyth GK, Visvader JE (2013) Global changes in the mammary epigenome are induced by hormonal cues and coordinated by Ezh2, Cell Reports 3:411-426.

